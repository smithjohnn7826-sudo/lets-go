name: ðŸš€ 6-Hour SSHX Session Runner (Alpine Linux)

# -----------------------------------------------------------------
# 1. EVENT TRIGGERS
# -----------------------------------------------------------------
on:
  schedule:
    - cron: '30 0,5,11,16,22 * * *'
  workflow_dispatch:

# -----------------------------------------------------------------
# 2. JOB DEFINITION
# -----------------------------------------------------------------
jobs:
  sshx_max_duration:
    name: Interactive Debug Shell (sshx)
    runs-on: ubuntu-latest
    timeout-minutes: 360 

    container:
      image: alpine/git:latest
      options: --user root

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      # Install minimal tools: gawk is needed, bash/procps might be useful
      - name: Install Dependencies
        run: |
          apk update
          apk add gawk bash procps curl util-linux

      # 1. Install and Start SSHX Session
      - name: 1. Install and Start SSHX Session
        id: start_sshx
        shell: bash
        run: |
          echo "Installing SSHX with one-liner..."
          curl -sSf https://sshx.io/get | sh
          
          SSHX_LOG="/tmp/sshx_link.log"
          echo "Starting SSHX session and capturing ALL output to $SSHX_LOG..."
          
          # Use 'script' to force a PTY, and send ALL output (stdout/stderr) to the log file
          > "$SSHX_LOG" # Clear the log file
          script -q -c "sshx run --headless" /dev/null > "$SSHX_LOG" 2>&1 &
          
          sleep 5
          
          # Set the log path for later use
          echo "sshx_log_file=$SSHX_LOG" >> $GITHUB_OUTPUT
          echo "SSHX process started in background."

      # 2. Wait for and Extract URL (Crucial Logging Step)
      - name: 2. Wait for and Extract URL (Logging)
        id: extract_url
        shell: bash
        run: |
          SSHX_LOG="${{ steps.start_sshx.outputs.sshx_log_file }}"
          TIMEOUT=90;
          SSHX_URL="";
          
          echo "Polling log file for URL (max $TIMEOUT seconds)...";
          
          for i in $(seq 1 $TIMEOUT); do
            SSHX_URL=$(grep 'Sharing session at:' "$SSHX_LOG" | gawk '{print $NF}' | tail -n 1);
            if [ -n "$SSHX_URL" ] && [[ "$SSHX_URL" == "https://sshx.io/s/"* ]]; then
              echo "::notice::URL found after $i seconds.";
              break;
            fi
            sleep 1;
          done;
          
          # Log the URL (or lack thereof) to the GitHub Actions job summary
          echo "--- SSHX Session Details ---"
          cat "$SSHX_LOG"
          
          if [ -n "$SSHX_URL" ] && [[ "$SSHX_URL" == "https://sshx.io/s/"* ]]; then
            echo "::notice::SSHX URL: $SSHX_URL"
            # Setting the URL as output for access in the job summary, if needed
            echo "sshx_url=$SSHX_URL" >> $GITHUB_OUTPUT
            
            # Write the URL to a permanent file for visibility in the job artifacts (optional, but helpful)
            echo $SSHX_URL > /tmp/sshx_url.txt
          else
            echo "::error::Failed to capture SSHX URL after $TIMEOUT seconds. Check the log content above."
            exit 1;
          fi

      # 3. Keep Job Alive for Max Duration
      - name: 3. Keep Job Alive for Max Duration
        if: success() 
        run: |
          SSHX_LOG="${{ steps.start_sshx.outputs.sshx_log_file }}"
          echo "SSHX session is running in the background."
          echo "The job will now run for the full 6 hours, monitoring the log file to stay alive."
          # Keeps the job alive by monitoring the log file.
          tail -f "$SSHX_LOG"
